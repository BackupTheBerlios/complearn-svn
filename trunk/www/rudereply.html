<html>
<head>
<title>
Mathematics, Open Source, and Verifiability in Computer Science
</title>
</head>
<body>

<h2>Mathematics, Open Source, and Verifiability in Computer Science</h2>

<center>by <a href="http://cilibrar.com/">Rudi Cilibrasi</a></center>

<p>
I have frequently encountered a common opinion among theoreticians that I
think deserves some exploration.  Just today, a highly skilled coworker,
Robert Spalek, made an unsurprising comment: he mentioned that he
thought it was stupid of me to program at a theoretical institute.  I say
this is unsurprising because I have heard it many times before from him and
many others at CWI.

<p>
My motivation for creating CompLearn, and programming in general, is quite
simple: it is out of the love for creation, love for fellow human beings,
and the wonder of making ``something from nothing''.  What is this something?
To me, it is truth.  Ultimate truth.  More ultimate than the truth that is
proclaimed or even the truths that are published in journals.  I think every
experienced computer programmer has seen the sense of confusion that arises
quite predictably every time the novice programs; though he was sure that the
program ``should work'', in fact defects are found during testing.  In the
case of programs like Microsoft Windows, even virtually unlimitted manpower
is unable to make much dent in an unrelenting flood of errors despite the
many programmers' best intentions and the very real fact that a large number of
users around the world are losing the most valuable thing that a computer can
steal from them: time.  The followers of the classical ``waterfall'' software
development model suffer a similar fate:  at first, an inexperienced manager
typically writes a specification and this is then delivered to a programmer.
Months later, the thing that is delivered is found to be useless and the
two will argue about who is at fault in the following fashion:  the
specification-writer will claim the programmer didn't properly follow the
spirit of his specification.  The programmer will claim the specification was
flawed and needed to be adjusted according to this-or-that design or
architecture decision.  The truth of the matter is that it is no easier to
write a perfect specification than it is to write a perfect computer program.
Both tasks are flatly impossible (in one shot) for humans when presented with
anything over about 1 page in length.  Good programmers know that we can assume
(in the absence of extreme formal methods and automatic verification tools)
that every page of formal text no matter what the language (math, Ruby, C or
otherwise) will usually contain at least one bug and perhaps several.  We also
know that specification and programming at the higher levels is a process of
learning and discovery, with iterative refinement to approach that ultimate
truth but never quite reaching it {\em by assumption}.  Agile programmers
graciously adopt a circular process of continuous refinement integrating the
learning process with the goal-driven structure that management and capital
investment require.  The key distinction between the mathematician's approach
and the agile programmer's is subtle but crucial: the mathematician's test
cycle is an open loop at first.  The agile programmer's is closed throughout.

<p>
  When I am involved in a mathematical paper, I do my best to ensure that the
proofs are correct to the best of my ability.  For me, this does not amount to
simply checking the proof for validity by hand.  That is what every careful
reader should do as a first step, and it is certain that good mathematicians
can catch many errors that way very quickly.  But more importantly, good
mathematicians can talk a very convincingly wrong line of reasoning in ways
that are often completely opaque to every other living human who reads them.
This is to me no more surprising that the oft-cited fact that most bugs go
forever unnoticed even with careful code review.  In our haplotyping paper, we
point out a couple longstanding problems in the literature that have existed
for about ten years and indeed have spawned a whole new branch of bioinformatic
combinatorics.  Although it is clear that many mathematicians have looked at
the (eroneous) proofs, not one had spotted it publicly despite all the
analysis and even formal review before publication.  To me, this is absolutely
unsurprising: I have seen that mathematics has accelerated in the last twenty
years tremendously and the level of training and specialization required to
understand these proofs continues to increase without bound, faster than our
natural evolution as a species and faster than our educational institutions
grow as well.  It is an increasingly smaller proportion of people worldwide
that can appreciate these most-advanced fruits at the edge of computer science,
and this presents an ever-increasing problem of verification and fidelity that
has so far gone unaddressed.  I find it silently amusing to
see the best mathematicians in the world provide their most confused looks
to one another in surprise as they exchange words about how weird it is.  The
truth is that it is not weird at all.  Everybody's Windows crashes and not
even the richest man in the world can fix it.  Nobody is a perfect calculating
machine.  All formal languages that allow for complexity are hard, and it only
gets harder as you keep building.  As humans, we do.  This is obvious to any
good software engineer and the only reason mathematicians have not yet widely
realized it is because they are looking at it from a false perspective of
human infallibility.

<p>
When I write software that implements and extends the mathematical theories
of universality in our papers I am looking to be surprised.  The most boring
outcome for me is also my target: to see the real results matching the
theory exactly.  That is the wonderful thing about {\em correct} theory:
it {\em never} disagrees with any {\em correct} implementation of the
theory.  And there are far more people in the world that can download,
play with, test, and perhaps debug the software than there are people who
are both willing and able to verify a complex mathematical proof.  To me,
all complex mathematical proofs that come without an open-source software
package or translation of the human-readable proof into machine-readable form
are deficient for the most basic reason in the scientific method: they are
{\em effectively unverifiable}.  I agree that there are many truly amazing
minds and it is remarkable what they can do with nothing more than a pencil
and paper.  This does not make my work redundant.  I point out that there is no
more {\em effectively objective} mathematical reality than that implemented by
a computer executing instructions meant to shed light on truth.  To me, the
human-readable proof is just the first step in a long process of
crystallization of intuition into real, verifiable, living hard truth.
To cut short this manifestation of the abstract to the actual is to promote
human folly and hubris.

</body>
</html>
