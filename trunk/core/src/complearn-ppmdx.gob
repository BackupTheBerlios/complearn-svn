requires 2.0.0
%headertop{
#include <glib/garray.h>
#include <libintl.h>
#include "real-compressor.h"
#include "complearn-real-compressor-adaptor.h"
#include "complearn-external-file-compressor.h"
%}

%{
#include <stdio.h>
#define _( O ) gettext( O )
#include "complearn/complearn-ppmdx.h"
#include "complearn/complearn-ppmdx-private.h"
#include "util.h"
#include <gmodule.h>

#define COMPRESSOR_NAME "ppmdx"

G_MODULE_EXPORT const gchar* g_module_check_init(void *gm)
{
  complearn_ppmdx_new();
  return NULL;
}

%}
class CompLearn:PpmdX from CompLearn:External:File:Compressor
 (interface CompLearn:Real:Compressor)
{
  private int megabytes;
  property INT megabytes
                      (nick = _("megabytes"),
                       blurb = _("megabytes of memory to use [1,256]"),
                       minimum = 1,
                       maximum = 256,
                       default_value = 256,
                       flags = CONSTRUCT,
                       link,
                       export);
  private int model_order;
  property INT model_order
                      (nick = _("model-order"),
                       blurb = _("Maximum model order [2,16]"),
                       minimum = 2,
                       maximum = 16,
                       default_value = 4,
                       flags = CONSTRUCT,
                       link,
                       export);
  private int restart_strategy;
  property INT restart_strategy
                      (nick = _("restart-strategy"),
                       blurb = _("0 = restart, 1 = cut off, 2 = freeze"),
                       minimum = 0,
                       maximum = 2,
                       default_value = 0,
                       flags = CONSTRUCT,
                       link,
                       export);
  public G:Object *
  new(void) {
    GObject *self = (GObject *) GET_NEW;
    SET_DEFAULT_PROPS(COMPRESSOR_NAME, COMPLEARN_PPMDX_GET_CLASS, self);
    return G_OBJECT (self);
  }
  interface CompLearn:Real:Compressor public G:String *
  decompress(CompLearn:Real:Compressor *rc, const G:String *input) {
CompLearnExternalFileCompressor *ec = COMPLEARN_EXTERNAL_FILE_COMPRESSOR(rc);
    g_assert(ec);
    char cmd[128];
    sprintf(cmd, "ppmd d inp.pmd");
    return complearn_external_file_compressor_transform_with_external_command(ec,cmd,input, "inp.pmd", "inp");
  }
  interface CompLearn:Real:Compressor public GString *
  compress(CompLearn:Real:Compressor *rc, const GString *input) {
  CompLearnExternalFileCompressor *ec = COMPLEARN_EXTERNAL_FILE_COMPRESSOR(rc);
    char cmd[128];
    sprintf(cmd, "ppmd e -r%d -o%d -m%d -s inp",
complearn_ppmdx_get_restart_strategy(COMPLEARN_PPMDX(rc)),
complearn_ppmdx_get_model_order(COMPLEARN_PPMDX(rc)),
complearn_ppmdx_get_megabytes(COMPLEARN_PPMDX(rc)));
    GString *result = complearn_external_file_compressor_transform_with_external_command(ec,cmd,input, "inp", "inp.pmd");
    return result;
  }
  interface CompLearn:Real:Compressor public gboolean
  is_operational(CompLearnRealCompressor *rc) {
    gboolean res = (g_find_program_in_path("ppmd") != NULL);
    return res;
  }
  interface CompLearn:RealCompressor public GString *
  canonical_extension(CompLearn:RealCompressor *rc) {
    return g_string_new("pmd");
  }
  interface CompLearn:Real:Compressor public GString *
  name (CompLearnRealCompressor * rc)
{
    return g_string_new(COMPRESSOR_NAME);
}
  interface CompLearn:Real:Compressor public GString *
blurb (CompLearnRealCompressor * rc)
{
    return g_string_new(_("PPM (Prediction by Partial Matching) version D"));
}

}
